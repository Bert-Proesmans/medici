var searchIndex = {};
searchIndex["game_rules"] = {"doc":"Example crate This crate is used to implement the game rules of a board game. It's idiomatic to build a seperate crate for the game rules implementation because the state machine produced by [`game_system`] contains non- accessible types to guarantee certain invariants are valid throughout the runtime of the machine.","items":[[0,"action","game_rules","Methods which, when invoked, execute the desired action of players.",null,null],[5,"start_game","game_rules::action","Method invoked to start the game.",null,{"inputs":[{"generics":["wait","emptystack"],"name":"machine"}],"output":{"generics":["machine","machineerror"],"name":"result"}}],[5,"end_turn","","Method invoked by user action: EndTurn",null,{"inputs":[{"generics":["wait","emptystack"],"name":"machine"}],"output":{"generics":["machine","machineerror"],"name":"result"}}],[0,"card_set","game_rules","Contains all game card definitions.",null,null],[4,"CardSet","game_rules::card_set","Enumeration of all known sets of cards.",null,null],[13,"Core","","Core card set, see module [`core`].",0,null],[13,"Test","","Test card set, see module [`test`].",0,null],[0,"core","","Contains the core card set. Core cards are necessary at minimum to properly start a game.",null,null],[0,"test","","This module contains all game cards which are part of the test-set.",null,null],[0,"trigger","game_rules","Methods which respond to a certain change in state within the game.",null,null],[5,"pre_end_turn_trigger","game_rules::trigger","DBG",null,{"inputs":[{"generics":["trigger"],"name":"machine"}],"output":{"generics":["machine","machineerror"],"name":"result"}}],[5,"turn_end_trigger","","Defines a trigger which will be run when the turn of the current player ends.",null,{"inputs":[{"generics":["trigger"],"name":"machine"}],"output":{"generics":["machine","machineerror"],"name":"result"}}],[5,"start_game_trigger","","Defines all activities which must happen when the game is started.",null,{"inputs":[{"generics":["trigger"],"name":"machine"}],"output":{"generics":["machine","machineerror"],"name":"result"}}]],"paths":[[4,"CardSet"]]};
searchIndex["game_system"] = {"doc":"Example crate Implements the state machine for a board game. Any type which interacts with the built state machine MUST be exported from this crate. Any type that's directly used from medici_core MUST transitively be re-exported here. Re-exporting allows the downstream crates to have a single dependancy, this crate.","items":[[0,"card","game_system","Specialized implementation of the [`Card`] game-object.",null,null],[17,"GAME_CARD_ID","game_system::card","Reserved identifier for Game cards.",null,null],[17,"PLAYER_CARD_ID","","Reserved identifier for Player cards.",null,null],[6,"Card","","The specialized [`Card`] structure.",null,null],[0,"entity","game_system","Specialized implementation of [`EntityStruct`] for our state machine.",null,null],[17,"GAME_E_ID","game_system::entity","The game entity should always have ID 0.",null,null],[6,"Entity","","The specialized entity structure for our state machine.",null,null],[0,"prototype","game_system","Specialized prototypes for our state machine.",null,null],[4,"ProtoItem","game_system::prototype","Autogenerated enum.",null,null],[13,"GameProto","","Autogenerated. See [`GameProto`].",0,null],[13,"PlayerProto","","Autogenerated. See [`PlayerProto`].",0,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"protoitem"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"protoitem"}],"output":{"name":"bool"}}],[11,"hash","","",0,null],[6,"Game","","Prototype for game behaviour specifically targetting the [`Entity`] defined within medici_core::prefab.",null,null],[6,"Player","","Prototype for player behaviour specifically targetting the [`Entity`] defined within medici_core::prefab.",null,null],[0,"runtime","game_system","Module pending removal",null,null],[5,"exec_triggers","game_system::runtime","Takes the provided machine (in [`Effect`] state) and executes direct and indirect triggers.",null,{"inputs":[{"generics":["effect"],"name":"machine"},{"name":"tt"}],"output":{"generics":["machine","machineerror"],"name":"result"}}],[0,"setup","game_system","Module containing state machine construction methods.",null,null],[0,"error","game_system::setup","Definitions for all possible errors thrown when setting up a new state machine.",null,null],[4,"SetupError","game_system::setup::error","Enumeration of possible errors when setting up a new game.",null,null],[13,"InvalidNameError","","Thrown when one of the provided player names is invalid.",1,null],[13,"EntityOverflow","","Thrown when max entities is overflown.",1,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",1,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",1,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",1,{"inputs":[{"name":"overflowerror"}],"output":{"name":"self"}}],[0,"state_machine","game_system","State machine implementation for the game: Goose game.",null,null],[0,"config","game_system::state_machine","Module containing types used to setup a new state-machine.",null,null],[3,"SetupConfig","game_system::state_machine::config","Structure used for setting up a new [`Machine`].",null,null],[12,"player_names","","Name for each player.",2,null],[12,"max_entities","","Maximum amount of entities to be stored inside this machine.",2,null],[17,"MAX_PLAYERS","","Constant defining how much memory at minimum MUST be (statically) allocated to support all players that joined the game.",null,null],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"self"}}],[0,"machine","game_system::state_machine","Defines the state machine itself.",null,null],[3,"Machine","game_system::state_machine::machine","The state machine.",null,null],[12,"transaction","","Field to store the provided Transaction object as rquired by the current state.",3,null],[12,"triggers","","Object for manipulating [`Trigger`]s.",3,null],[12,"entities","","Object for manipulating [`Entity`]s.",3,null],[12,"transactions","","Storage object allowing [`PushdownInto`] and [`PullupInto`] to store the [`Transaction`] objects for each state to be re-used.",3,null],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"machine"}}],[11,"get","","",3,{"inputs":[{"name":"self"}],"output":{"name":"triggerservice"}}],[11,"get_mut","","",3,{"inputs":[{"name":"self"}],"output":{"name":"triggerservice"}}],[11,"get","","",3,{"inputs":[{"name":"self"}],"output":{"name":"entityservice"}}],[11,"get_mut","","",3,{"inputs":[{"name":"self"}],"output":{"name":"entityservice"}}],[0,"marker","game_system::state_machine","Additional marker traits for our game.",null,null],[0,"state","","Submodule defining all state types of the state machine.",null,null],[0,"leaf","game_system::state_machine::state","Module for leaf state types.",null,null],[3,"Peri","game_system::state_machine::state::leaf","Type representing a timing relationship. Peri X means during/while X is executed.",null,null],[3,"Post","","Type representing a timing relationship. Pre X means after X is executed.",null,null],[3,"Pre","","Type representing a timing relationship. Pre X means before X is executed.",null,null],[4,"TimingItem","","Autogenerated enum.",null,null],[13,"Pre","","Autogenerated. See [`Pre`].",4,null],[13,"Peri","","Autogenerated. See [`Peri`].",4,null],[13,"Post","","Autogenerated. See [`Post`].",4,null],[0,"triggerable","","All types which can be used to activate triggers awaiting activation.",null,null],[3,"Start","game_system::state_machine::state::leaf::triggerable","Wait condition state until the game has been started.",null,null],[3,"Input","","Wait condition state until the user has provided input.",null,null],[3,"EndTurn","","Action condition state until the user has provided input.",null,null],[3,"PlayCard","","Action condition state indicating a card will be played.",null,null],[3,"Attack","","Action condition state indicating an attack will commence.",null,null],[3,"Damage","","Trigger condition for taken damage.",null,null],[4,"TriggerItem","","Autogenerated enum.",null,null],[13,"Start","","Autogenerated. See [`Start`].",5,null],[13,"Input","","Autogenerated. See [`Input`].",5,null],[13,"EndTurn","","Autogenerated. See [`EndTurn`].",5,null],[13,"PlayCard","","Autogenerated. See [`PlayCard`].",5,null],[13,"Attack","","Autogenerated. See [`Attack`].",5,null],[13,"Damage","","Autogenerated. See [`Damage`].",5,null],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"start"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"input"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"endturn"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"playcard"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"attack"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"damage"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"triggeritem"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"triggeritem"}],"output":{"name":"bool"}}],[11,"hash","","",5,null],[0,"toplevel","game_system::state_machine::state","Module for toplevel state types.",null,null],[3,"Action","game_system::state_machine::state::toplevel","State indicating dynamic execution of the specific action is in progress.",null,null],[3,"DeathEffect","","Specific state where [`Entity`] death processing is triggered.",null,null],[3,"Effect","","First state used to execute an effect chain caused by the substate ([`Actionable`]).",null,null],[3,"Finished","","State indicating finalization of the state machine.",null,null],[3,"RecurseEffect","","Chained effect caused by an specific [`Actionable`].",null,null],[3,"Trigger","","Exact state used to execute effects.",null,null],[3,"Wait","","State indicating a pause until an input event has been generated.",null,null],[0,"prelude","game_system::state_machine::state","All state types handily packaged to get started with the defined state machine.",null,null],[0,"transaction","game_system::state_machine","Types used to convey transition related information.",null,null],[3,"Epsilon","game_system::state_machine::transaction","Empty Transaction object.",null,null],[4,"TransactionItem","","Collection of known Transaction structures wrapped into a Sized item.",null,null],[13,"Epsilon","","See [`Epsilon`]",12,null],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"transactionitem"}}],[11,"from","","",12,{"inputs":[{"name":"epsilon"}],"output":{"name":"self"}}],[11,"try_from","","",13,{"inputs":[{"name":"transactionitem"}],"output":{"name":"result"}}],[0,"transitions","game_system::state_machine","Defines all transitions within our state machine.",null,null],[11,"pushdown_from","game_system::state_machine::machine","",3,null],[11,"pullup_from","","",3,{"inputs":[{"generics":["trigger"],"name":"machine"}],"output":{"generics":["machineerror"],"name":"result"}}],[11,"pushdown_from","","",3,null],[11,"pullup_from","","",3,{"inputs":[{"generics":["trigger"],"name":"machine"}],"output":{"generics":["machineerror"],"name":"result"}}],[11,"pushdown_from","","",3,null],[11,"pullup_from","","",3,{"inputs":[{"generics":["trigger"],"name":"machine"}],"output":{"generics":["machineerror"],"name":"result"}}],[11,"pushdown_from","","",3,null],[11,"pullup_from","","",3,{"inputs":[{"generics":["recurseeffect"],"name":"machine"}],"output":{"generics":["machineerror"],"name":"result"}}],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[11,"pushdown_from","","",3,null],[11,"pullup_from","","",3,{"inputs":[{"generics":["effect"],"name":"machine"}],"output":{"generics":["machineerror"],"name":"result"}}],[11,"pushdown_from","","",3,null],[11,"pullup_from","","",3,{"inputs":[{"generics":["effect"],"name":"machine"}],"output":{"generics":["machineerror"],"name":"result"}}],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[11,"transition_from","","",3,null],[0,"tag","game_system","Module containing the property tags which can be attributed to [`Entity`]s and other game-objects.",null,null],[4,"EntityTags","game_system::tag","Enumeration of all entity property keys.",null,null],[13,"MaxPlayers","","Amount of players registered on this game.",14,null],[13,"CurrentPlayerOrd","","Index of the player who is currently on-turn. This index starts counting at 1. eg: First-, second-, third-,.. player.",14,null],[13,"RemainingTurns","","Holds the amount of turns the current player has remaining. 0 means the next player's turn will start on turn_end.",14,null],[13,"StartHandSize","","Holds the amount of cards you start the game with.",14,null],[13,"Attack","","Amount of damage an entity can do.",14,null],[13,"Health","","Amount of health an entity has.",14,null],[13,"Damage","","Amount of damage an entity has taken.",14,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",14,null],[11,"eq","","",14,{"inputs":[{"name":"self"},{"name":"entitytags"}],"output":{"name":"bool"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"entitytags"}}],[0,"re_export","game_system","Exported types from [`medici_core`].",null,null],[0,"function","game_system::re_export","Contains the core functionality items for our system.",null,null],[8,"StateContainer","game_system::re_export::function","Trait generalizing over any structure that could act as a container of states.",null,null],[16,"State","","Type of the current state held by the state machine.",15,null],[16,"Transaction","","Type of transaction object necessary to transition into the current state of the machine.",15,null],[16,"TimingEnum","","Type which enumerates all possible timings contained by the machine.",15,null],[16,"TriggerEnum","","Type which enumerates all possible triggers contained by the machine.",15,null],[16,"TransitionRecord","","Type representing the stack of types where the container state was transitioned in a pushdown manner.",15,null],[8,"State","","Trait generalizing over any state that's present in the state machine.",null,null],[16,"Transaction","","Type of structure which must be provided when transitioning into the state represented by the enclosing type.",16,null],[8,"EffectState","","Trait generalizing over any state which is used to bootstrap an execution of triggers.",null,null],[8,"TriggerState","","Trait generalizing over any state that's used to pass into trigger callbacks when trigger conditions are met.",null,null],[16,"Timing","","Encoded type value representing the timing (related to triggers) of the current state.",17,null],[16,"Trigger","","Encoded type value representing the trigger of the current state.",17,null],[8,"Identifiable","","Trait enforcing implementing objects to expose their identifier. The uniqueness of this identifier depends on the implementing object itself.",null,null],[16,"ID","","The type of identifier used to pass between functions during state machine execution. This type MUST be [`Copy`] because storing this identifier is the idiomatic way of passing \"references\" around.",18,null],[10,"id","","Returns the identifier of the implementing object.",18,null],[6,"EntityId","","Type that's generally used to identify and order [`Entity`] objects.",null,null],[8,"Entity","","Trait representing an object which properties can be altered dynamically (at runtime).",null,null],[8,"EntityBuilder","","Trait used to create a new [`Entity`] object.",null,null],[10,"new_with_id","","Build a new [`Entity`] with the provided identifier.",19,null],[8,"Card","","Trait representing an actual game card.",null,null],[16,"TimingEnum","","All timing types this card holds listeners for.",20,null],[16,"TriggerEnum","","All trigger types this card holds listeners for.",20,null],[8,"CardBuilder","","Trait used to create a new [`Card`] object.",null,null],[10,"new_with_id","","Build a new [`Card`] with the provided identifier.",21,{"inputs":[{"name":"i"}],"output":{"name":"c"}}],[8,"ServiceCompliance","","Trait for implementing a certain service on the state machine.",null,null],[10,"get","","Retrieves an immutable reference to service `S`.",22,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[10,"get_mut","","Retrieves a mutable reference to service `S`.",22,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[8,"StackStorageCompliance","","Defines stack behaviour for a certain storage object.",null,null],[16,"Item","","The type of items found within the implementing storage.",23,null],[10,"push","","Adds the provided item onto this stack.",23,null],[10,"pop","","Removes the top most item of the stack.",23,{"inputs":[{"name":"self"}],"output":{"generics":["stackpoperror"],"name":"result"}}],[8,"IndexedStorageCompliance","","Defines indexed behaviour for a certain storage object.",null,null],[16,"Item","","The type of items found within the implementing storage.",24,null],[10,"get","","Retrieves a reference to the requested item matching the provided identifier.",24,null],[10,"get_mut","","Retrieves a reference to the requested item matching the provided identifier.",24,null],[8,"ArrayStorageCompliance","","Defines array access behaviour for storage objects.",null,null],[16,"Item","","The type of items found within the implementing storage.",25,null],[10,"as_slice","","Returns the current storage as a slice, which is an indexed storage.",25,null],[10,"as_slice_mut","","Returns the current storage as a slice, which is an indexed storage.",25,null],[3,"CardId","","Type that's generally used to identify and order [`Card`] objects.",null,null],[0,"marker","game_system::re_export","Primitive traits which can be used as constraints by the core components.",null,null],[8,"Transaction","game_system::re_export::marker","Types used to transition between state machine States.",null,null],[8,"TransactionContainer","","Types which generalize multiple transactions into 1 [`Sized`] structure so the transactions themselves can be safely stored in memory.",null,null],[8,"Service","","Types which attribute functionality to state machines.",null,null],[8,"ProtoEnumerator","","Types which enumerate all known [`Prototype`]s.",null,null],[8,"Prototype","","Types which attribute functionality to [`Entity`]s within the machine.",null,null],[8,"TimingEnumerator","","Types which enumerate all possible timings at which moment a trigger can be executed.",null,null],[8,"Timing","","Types which reflect the timing when a [`Triggerable`] should be executed.",null,null],[8,"TriggerEnumerator","","Types which enumerate all possible triggers which the machine facilitates reacting to.",null,null],[8,"Triggerable","","(State) Types which reflect an event after which functionality awaiting these events will be executed.",null,null],[8,"TopLevel","","(State) Types which are directly contained by the state machine.",null,null],[8,"Waitable","","(State) Types which represent a condition for when the state machine itself should resume execution.",null,null],[8,"Actionable","","(State) Types which represent actions a user want to perform that activate the machine to work out its effects.",null,null],[0,"service","game_system::re_export","Types that provide functionality to your application. These types can be added AD-HOC to your (state) machine declaration. Other components of this framework also need some of these services to be implemented before use.",null,null],[0,"card","game_system::re_export::service","Contains functionality to work with [`Card`]s.",null,null],[3,"CardService","game_system::re_export::service::card","Object allowing manipulation of game [`Card`]s.",null,null],[0,"entity","game_system::re_export::service","Contains functionality to work with [`Entity`]s.",null,null],[3,"EntityService","game_system::re_export::service::entity","Structure for working with [`Entity`] objects.",null,null],[0,"trigger","game_system::re_export::service","Contains the functionality to work with [`Trigger`]s.",null,null],[3,"TriggerWrapper","game_system::re_export::service::trigger","Safe abstraction over UnsafeTrigger objects.",null,null],[3,"TriggerService","","Structure wrapping and containing all [`Trigger`]s registered on the state machine.",null,null],[3,"CardService","game_system::re_export::service","Object allowing manipulation of game [`Card`]s.",null,null],[3,"TriggerService","","Structure wrapping and containing all [`Trigger`]s registered on the state machine.",null,null],[3,"EntityService","","Structure for working with [`Entity`] objects.",null,null],[8,"PullupFrom","game_system::re_export","Trait defining the contract for two-way transitions of the state machine. The Transaction object of the outgoing state is stored for re-use. This kind of transition will write state change history into the compile-time stack ([`CTStack`]).",null,null],[10,"pullup_from","","Transition from the provided state into the implementing state.",26,{"inputs":[{"name":"t"}],"output":{"generics":["machineerror"],"name":"result"}}],[8,"PushdownFrom","","Trait defining the contract for two-way transitions of the state machine. The transition this trait defines is meant as a temporary one where the control flow will result in the state machine eventually performs a [`PullupFrom`] transition. Effectively reversing the Pushdown. The Transaction object of the outgoing state is stored for re-use. This kind of transition will write state change history into the compile-time stack ([`CTStack`]).",null,null],[10,"pushdown_from","","Transition from the provided state into the implementing state.",27,null],[8,"TransitionFrom","","Trait defining the contract for one-way transitions of the state machine. This kind of transition preserves the state change history.",null,null],[10,"transition_from","","Transition from the provided state into the implementing state.",28,null],[0,"storage","","Types with each different functionality to store data.",null,null],[0,"card","game_system::re_export::storage","Module containing structures for storing game card objects.",null,null],[3,"CardStorage","game_system::re_export::storage::card","Structure holding onto all cards defined for a specific machine.",null,null],[12,"cards","","Contains the cards.",29,null],[0,"entity","game_system::re_export::storage","Module containing structures for storing entities.",null,null],[3,"EntityStorage","game_system::re_export::storage::entity","Structure wrapping a [`Vec`] to provide a container for (all) entities within the state machine.",null,null],[0,"transaction","game_system::re_export::storage","Module containing types for storing [`Transaction`] objects.",null,null],[3,"TransactionStorage","game_system::re_export::storage::transaction","Object for storing [`Transaction`] objects.",null,null],[0,"trigger","game_system::re_export::storage","Module containing types for storing game triggers.",null,null],[3,"UnsafeTrigger","game_system::re_export::storage::trigger","Structure serializng/generalizing a trigger.",null,null],[12,"timing","","(Sized) Timing value belonging to the callback, see func_pointer.",30,null],[12,"trigger","","(Sized) Trigger value belonging to the callback, see func_pointer.",30,null],[12,"func_pointer","","The callback pointer which must be transmuted and executed when the conditions of the running state machine match the ones contained within this structure.",30,null],[3,"TriggerStorage","","Structure used to store a portable format of trigger entries, see [`UnsafeTrigger`].",null,null],[12,"triggers","","Container of all triggers registered with the running state machine.",31,null],[3,"CardStorage","game_system::re_export::storage","Structure holding onto all cards defined for a specific machine.",null,null],[12,"cards","","Contains the cards.",29,null],[3,"TransactionStorage","","Object for storing [`Transaction`] objects.",null,null],[3,"TriggerStorage","","Structure used to store a portable format of trigger entries, see [`UnsafeTrigger`].",null,null],[12,"triggers","","Container of all triggers registered with the running state machine.",31,null],[3,"EntityStorage","","Structure wrapping a [`Vec`] to provide a container for (all) entities within the state machine.",null,null],[0,"prelude","game_system","Often used types exported together for ease of use.",null,null],[0,"error","game_system::prelude","Types, to be used within the system, providing context of unexpected behaviour.",null,null],[3,"MachineError","game_system::prelude::error","User facing error type indicating a failure during evalutation/computation of the state machine.",null,null],[4,"ErrorKind","","Enumeration of publicl cases of state machine failures.",null,null],[13,"ConstraintError","","Error indicating some constraint failed to assert at runtime.",32,null],[13,"LogicError","","Error indicating the developer has introduced a logic error in his code.",32,null],[13,"Custom","","Error allowing to print an entirely custom message",32,null],[8,"HydratedErrorExt","","TODO",null,null],[10,"hydrate","","TODO",33,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"machineerror"}}],[8,"FrontendErrorExt","","Trait facilitating error creation with a snapshot of the state machine attached.",null,null],[10,"infuse","","Builds a [`MachineError`] from some error or empty option.",34,{"inputs":[{"name":"self"},{"name":"errorkind"},{"name":"i"}],"output":{"name":"machineerror"}}],[10,"infuse_with","","Builds a [`MachineError`] from some error or empty option. The [`ErrorKind`] invariant will be [`ErrorKind::Custom`] which will contain the string type passed into this method.",34,{"inputs":[{"name":"self"},{"name":"f"},{"name":"m"}],"output":{"name":"machineerror"}}],[0,"custom_type","","Error types which represent one specific kind of error (failure). These errors are reported within functions that manipulate properties of the state machine, but will be wrapped into [`MachineError`] eventually.",null,null],[3,"RuntimeConstraintError","game_system::prelude::error::custom_type","Type used for indicating failure to meet specified constraints.",null,null],[3,"TransactionUnpackError","","Code failed to push a new item onto the chosen stack.",null,null],[3,"StackPushError","","Code failed to push a new item onto the chosen stack.",null,null],[3,"StackPopError","","Code failed to push a new item onto the chosen stack.",null,null],[3,"OverflowError","","Specific error thrown to indicate the system cannot execute the request under constrained circumstances.",null,null],[12,"0","","",35,null],[3,"InvalidEntityMutUnwrap","","Code failed to get a mutable reference to an [`Entity`].",null,null],[3,"MissingEntityError","","Specific error thrown when the requested entity-id is not known.",null,null],[12,"0","","",36,null],[3,"MissingCardError","","Specific error thrown when the requested card-id is not known.",null,null],[12,"0","","",37,null],[3,"MissingPropertyError","","Specific error thrown when the requested property is not known.",null,null],[12,"0","","",38,null],[12,"1","","",38,null],[3,"MissingPrototypeError","","Specific error thrown when the requested entity-id is not known.",null,null],[12,"0","","",39,null],[12,"1","","",39,null],[3,"IDCollisionError","","Error thrown when the provided object's ID collides with an already known ID.",null,null],[12,"0","","",40,null],[4,"TriggerFail","","Enumeration of failure cases working with [`Trigger`]s.",null,null],[13,"CallbackNull","","Error indicating the callback pointer is invalid.",41,null],[13,"ConstraintFail","","Error indicating the provided machine does not validate the [`Trigger`] constraints.",41,null],[4,"ErrorKind","game_system::prelude","Enumeration of publicl cases of state machine failures.",null,null],[13,"ConstraintError","","Error indicating some constraint failed to assert at runtime.",32,null],[13,"LogicError","","Error indicating the developer has introduced a logic error in his code.",32,null],[13,"Custom","","Error allowing to print an entirely custom message",32,null],[8,"FrontendErrorExt","","Trait facilitating error creation with a snapshot of the state machine attached.",null,null],[10,"infuse","","Builds a [`MachineError`] from some error or empty option.",34,{"inputs":[{"name":"self"},{"name":"errorkind"},{"name":"i"}],"output":{"name":"machineerror"}}],[10,"infuse_with","","Builds a [`MachineError`] from some error or empty option. The [`ErrorKind`] invariant will be [`ErrorKind::Custom`] which will contain the string type passed into this method.",34,{"inputs":[{"name":"self"},{"name":"f"},{"name":"m"}],"output":{"name":"machineerror"}}],[8,"HydratedErrorExt","","TODO",null,null],[10,"hydrate","","TODO",33,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"machineerror"}}],[3,"MachineError","","User facing error type indicating a failure during evalutation/computation of the state machine.",null,null],[0,"function","","Contains the core functionality items for our system.",null,null],[8,"StateContainer","game_system::prelude::function","Trait generalizing over any structure that could act as a container of states.",null,null],[16,"State","","Type of the current state held by the state machine.",15,null],[16,"Transaction","","Type of transaction object necessary to transition into the current state of the machine.",15,null],[16,"TimingEnum","","Type which enumerates all possible timings contained by the machine.",15,null],[16,"TriggerEnum","","Type which enumerates all possible triggers contained by the machine.",15,null],[16,"TransitionRecord","","Type representing the stack of types where the container state was transitioned in a pushdown manner.",15,null],[8,"State","","Trait generalizing over any state that's present in the state machine.",null,null],[16,"Transaction","","Type of structure which must be provided when transitioning into the state represented by the enclosing type.",16,null],[8,"EffectState","","Trait generalizing over any state which is used to bootstrap an execution of triggers.",null,null],[8,"TriggerState","","Trait generalizing over any state that's used to pass into trigger callbacks when trigger conditions are met.",null,null],[16,"Timing","","Encoded type value representing the timing (related to triggers) of the current state.",17,null],[16,"Trigger","","Encoded type value representing the trigger of the current state.",17,null],[8,"Identifiable","","Trait enforcing implementing objects to expose their identifier. The uniqueness of this identifier depends on the implementing object itself.",null,null],[16,"ID","","The type of identifier used to pass between functions during state machine execution. This type MUST be [`Copy`] because storing this identifier is the idiomatic way of passing \"references\" around.",18,null],[10,"id","","Returns the identifier of the implementing object.",18,null],[6,"EntityId","","Type that's generally used to identify and order [`Entity`] objects.",null,null],[8,"Entity","","Trait representing an object which properties can be altered dynamically (at runtime).",null,null],[8,"EntityBuilder","","Trait used to create a new [`Entity`] object.",null,null],[10,"new_with_id","","Build a new [`Entity`] with the provided identifier.",19,null],[8,"Card","","Trait representing an actual game card.",null,null],[16,"TimingEnum","","All timing types this card holds listeners for.",20,null],[16,"TriggerEnum","","All trigger types this card holds listeners for.",20,null],[8,"CardBuilder","","Trait used to create a new [`Card`] object.",null,null],[10,"new_with_id","","Build a new [`Card`] with the provided identifier.",21,{"inputs":[{"name":"i"}],"output":{"name":"c"}}],[8,"ServiceCompliance","","Trait for implementing a certain service on the state machine.",null,null],[10,"get","","Retrieves an immutable reference to service `S`.",22,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[10,"get_mut","","Retrieves a mutable reference to service `S`.",22,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[8,"StackStorageCompliance","","Defines stack behaviour for a certain storage object.",null,null],[16,"Item","","The type of items found within the implementing storage.",23,null],[10,"push","","Adds the provided item onto this stack.",23,null],[10,"pop","","Removes the top most item of the stack.",23,{"inputs":[{"name":"self"}],"output":{"generics":["stackpoperror"],"name":"result"}}],[8,"IndexedStorageCompliance","","Defines indexed behaviour for a certain storage object.",null,null],[16,"Item","","The type of items found within the implementing storage.",24,null],[10,"get","","Retrieves a reference to the requested item matching the provided identifier.",24,null],[10,"get_mut","","Retrieves a reference to the requested item matching the provided identifier.",24,null],[8,"ArrayStorageCompliance","","Defines array access behaviour for storage objects.",null,null],[16,"Item","","The type of items found within the implementing storage.",25,null],[10,"as_slice","","Returns the current storage as a slice, which is an indexed storage.",25,null],[10,"as_slice_mut","","Returns the current storage as a slice, which is an indexed storage.",25,null],[3,"CardId","","Type that's generally used to identify and order [`Card`] objects.",null,null],[8,"ArrayStorageCompliance","game_system::prelude","Defines array access behaviour for storage objects.",null,null],[16,"Item","","The type of items found within the implementing storage.",25,null],[10,"as_slice","","Returns the current storage as a slice, which is an indexed storage.",25,null],[10,"as_slice_mut","","Returns the current storage as a slice, which is an indexed storage.",25,null],[8,"CardTrait","","Trait representing an actual game card.",null,null],[16,"TimingEnum","","All timing types this card holds listeners for.",20,null],[16,"TriggerEnum","","All trigger types this card holds listeners for.",20,null],[8,"CardBuilder","","Trait used to create a new [`Card`] object.",null,null],[10,"new_with_id","","Build a new [`Card`] with the provided identifier.",21,{"inputs":[{"name":"i"}],"output":{"name":"c"}}],[3,"CardId","","Type that's generally used to identify and order [`Card`] objects.",null,null],[8,"EntityTrait","","Trait representing an object which properties can be altered dynamically (at runtime).",null,null],[8,"EntityBuilder","","Trait used to create a new [`Entity`] object.",null,null],[10,"new_with_id","","Build a new [`Entity`] with the provided identifier.",19,null],[6,"EntityId","","Type that's generally used to identify and order [`Entity`] objects.",null,null],[8,"Identifiable","","Trait enforcing implementing objects to expose their identifier. The uniqueness of this identifier depends on the implementing object itself.",null,null],[16,"ID","","The type of identifier used to pass between functions during state machine execution. This type MUST be [`Copy`] because storing this identifier is the idiomatic way of passing \"references\" around.",18,null],[10,"id","","Returns the identifier of the implementing object.",18,null],[8,"IndexedStorageCompliance","","Defines indexed behaviour for a certain storage object.",null,null],[16,"Item","","The type of items found within the implementing storage.",24,null],[10,"get","","Retrieves a reference to the requested item matching the provided identifier.",24,null],[10,"get_mut","","Retrieves a reference to the requested item matching the provided identifier.",24,null],[8,"ServiceCompliance","","Trait for implementing a certain service on the state machine.",null,null],[10,"get","","Retrieves an immutable reference to service `S`.",22,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[10,"get_mut","","Retrieves a mutable reference to service `S`.",22,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[8,"StackStorageCompliance","","Defines stack behaviour for a certain storage object.",null,null],[16,"Item","","The type of items found within the implementing storage.",23,null],[10,"push","","Adds the provided item onto this stack.",23,null],[10,"pop","","Removes the top most item of the stack.",23,{"inputs":[{"name":"self"}],"output":{"generics":["stackpoperror"],"name":"result"}}],[8,"PullupInto","","Syntax simplifying trait in accordance to [`PullupFrom`].",null,null],[10,"pullup","","In accordance with [`PullupFrom::pullup_from`].",42,{"inputs":[{"name":"self"}],"output":{"generics":["machineerror"],"name":"result"}}],[8,"PushdownInto","","Syntax simplifying trait in accordance to [`PushdownFrom`].",null,null],[10,"pushdown","","In accordance with [`PushdownFrom::pushdown_from`].",43,null],[8,"TransitionInto","","Syntax simplifying trait in accordance to [`TransitionFrom`].",null,null],[10,"transition","","In accordance with [`TransitionFrom::transition_from`].",44,null],[5,"pack_transaction","","Transform a transaction into the wrapping variant.",null,{"inputs":[{"name":"t"}],"output":{"name":"tc"}}],[5,"unpack_transaction","","Unpack a wrapped transaction into an owned value.",null,{"inputs":[{"name":"tc"}],"output":{"generics":["transactionunpackerror"],"name":"result"}}],[17,"GAME_E_ID","","The game entity should always have ID 0.",null,null],[14,"card_impl","game_system","Use this macro to build implementations of new cards.",null,null],[11,"new","game_system::state_machine::machine","Creates a new state machine ready to be started.",3,{"inputs":[{"name":"setupconfig"}],"output":{"generics":["setuperror"],"name":"result"}}],[11,"from","game_system::prelude::error::custom_type","",45,null],[11,"from","game_system::re_export::storage::trigger","",30,{"inputs":[{"name":"triggerwrapper"}],"output":{"name":"unsafetrigger"}}],[11,"eq","game_system::state_machine::state::leaf","",4,{"inputs":[{"name":"self"},{"name":"timingitem"}],"output":{"name":"bool"}}],[11,"eq","game_system::prelude::error::custom_type","",41,{"inputs":[{"name":"self"},{"name":"triggerfail"}],"output":{"name":"bool"}}],[11,"eq","game_system::prelude","",32,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"ne","","",32,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"get","game_system::re_export::storage","",29,null],[11,"get_mut","","",29,null],[11,"cause","game_system::prelude::error::custom_type","",41,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",41,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"cause","game_system::prelude","",46,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",46,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"cause","game_system::prelude::error::custom_type","",47,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",47,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"cause","","",48,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",48,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"cause","","",49,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",49,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"cause","","",35,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",35,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"cause","","",50,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",50,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"cause","","",45,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",45,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"cause","game_system::prelude","",32,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",32,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"hash","game_system::state_machine::state::leaf","",4,null],[11,"push","game_system::re_export::storage","",51,null],[11,"pop","","",51,{"inputs":[{"name":"self"}],"output":{"generics":["stackpoperror"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",49,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::re_export::service","",52,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::state::toplevel","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",54,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::re_export::storage::trigger","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::re_export::storage","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::state::leaf","",55,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::re_export::service","",56,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::re_export::service::trigger","",57,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude","",58,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::state::toplevel","",59,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",47,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::state::leaf","",60,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::state::toplevel","",61,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::transaction","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",48,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::state::toplevel","",62,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::re_export::storage","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::state::leaf","",63,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude","",46,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",50,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::state::leaf","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",45,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",41,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::re_export::storage","",64,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::state_machine::state::toplevel","",65,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",66,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::re_export::service","",67,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"clone","game_system::state_machine::state::leaf","",55,{"inputs":[{"name":"self"}],"output":{"name":"peri"}}],[11,"clone","game_system::re_export::service","",67,{"inputs":[{"name":"self"}],"output":{"name":"triggerservice"}}],[11,"clone","game_system::state_machine::state::leaf","",60,{"inputs":[{"name":"self"}],"output":{"name":"post"}}],[11,"clone","game_system::prelude","",58,{"inputs":[{"name":"self"}],"output":{"name":"cardid"}}],[11,"clone","game_system::state_machine::state::toplevel","",54,{"inputs":[{"name":"self"}],"output":{"name":"wait"}}],[11,"clone","game_system::re_export::storage::trigger","",30,{"inputs":[{"name":"self"}],"output":{"name":"unsafetrigger"}}],[11,"clone","game_system::state_machine::state::toplevel","",65,{"inputs":[{"name":"self"}],"output":{"name":"finished"}}],[11,"clone","game_system::re_export::storage","",64,{"inputs":[{"name":"self"}],"output":{"name":"entitystorage"}}],[11,"clone","game_system::state_machine::state::toplevel","",62,{"inputs":[{"name":"self"}],"output":{"name":"recurseeffect"}}],[11,"clone","","",59,{"inputs":[{"name":"self"}],"output":{"name":"deatheffect"}}],[11,"clone","game_system::prelude","",32,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"clone","game_system::re_export::storage","",51,{"inputs":[{"name":"self"}],"output":{"name":"transactionstorage"}}],[11,"clone","game_system::state_machine::state::toplevel","",61,{"inputs":[{"name":"self"}],"output":{"name":"trigger"}}],[11,"clone","game_system::re_export::storage","",31,{"inputs":[{"name":"self"}],"output":{"name":"triggerstorage"}}],[11,"clone","game_system::state_machine::state::leaf","",4,{"inputs":[{"name":"self"}],"output":{"name":"timingitem"}}],[11,"clone","game_system::re_export::service","",56,{"inputs":[{"name":"self"}],"output":{"name":"entityservice"}}],[11,"clone","game_system::state_machine::state::toplevel","",66,{"inputs":[{"name":"self"}],"output":{"name":"effect"}}],[11,"clone","game_system::re_export::storage","",29,{"inputs":[{"name":"self"}],"output":{"name":"cardstorage"}}],[11,"clone","game_system::state_machine::transaction","",13,{"inputs":[{"name":"self"}],"output":{"name":"epsilon"}}],[11,"clone","game_system::state_machine::state::toplevel","",53,{"inputs":[{"name":"self"}],"output":{"name":"action"}}],[11,"clone","game_system::state_machine::state::leaf","",63,{"inputs":[{"name":"self"}],"output":{"name":"pre"}}],[11,"clone","game_system::prelude::error::custom_type","",41,{"inputs":[{"name":"self"}],"output":{"name":"triggerfail"}}],[11,"from_type","game_system::state_machine::state::leaf","",4,{"inputs":[],"output":{"name":"timingitem"}}],[11,"from_type","","",4,{"inputs":[],"output":{"name":"timingitem"}}],[11,"from_type","","",4,{"inputs":[],"output":{"name":"timingitem"}}],[11,"as_slice","game_system::re_export::storage","",64,null],[11,"as_slice_mut","","",64,null],[11,"fmt","game_system::prelude::error::custom_type","",49,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude","",46,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",45,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude","",58,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",41,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","game_system::prelude::error::custom_type","",50,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",48,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",47,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"new","game_system::prelude","Creates a new identifier structure for a card.",58,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"cardid"}}],[11,"from_set","","Creates a new identifier structure for a card.",58,{"inputs":[{"name":"s"},{"name":"u32"}],"output":{"name":"cardid"}}],[11,"new","game_system::re_export::service","Creates a new object of this service.",52,{"inputs":[],"output":{"name":"cardservice"}}],[11,"register_card","","Stores the provided card.",52,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"generics":["idcollisionerror"],"name":"result"}}],[11,"get_card","","Fetches the card matching the provided identifier from this storage object.",52,null],[11,"new","","Creates a new object for storage.",56,{"inputs":[{"name":"m"}],"output":{"name":"entityservice"}}],[11,"new_entity","","Build a new entity which is kept inside this storage object.",56,{"inputs":[{"name":"self"}],"output":{"generics":["overflowerror"],"name":"result"}}],[11,"get","","Retrieves a reference to the entity matching the id.",56,null],[11,"get_mut","","Retrieves a mutable reference to the entity matching the id.",56,null],[11,"new","game_system::re_export::service::trigger","Constructs a new trigger method wrapper from the provided method.",57,null],[11,"try_from_trigger_entry","","Build a safe wrapper from a [`UnsafeTrigger`] object.",57,{"inputs":[{"name":"unsafetrigger"}],"output":{"generics":["triggerwrapper","triggerfail"],"name":"result"}}],[11,"into_callback","","Consumes this wrapper to retrieve the callback it contains.",57,null],[11,"new","game_system::re_export::service","Creates a new object of this service.",67,{"inputs":[],"output":{"name":"triggerservice"}}],[11,"add_trigger","","Add a new trigger to the store.",67,null],[11,"retrieve_all_triggers","","Returns an iterator over all stored triggers.",67,null],[11,"retrieve_triggers","","Retrieve all triggers matching the provided machine.",67,null],[11,"new","game_system::re_export::storage","Creates a new object for card storage.",29,{"inputs":[],"output":{"name":"cardstorage"}}],[11,"try_insert_card","","Tries to insert the provided card into this storage object.",29,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"generics":["idcollisionerror"],"name":"result"}}],[11,"new","","Creates a new object for storage.",64,{"inputs":[],"output":{"name":"entitystorage"}}],[11,"push","","Stores the provided item into this object.",64,null],[11,"new","","Creates a new instance of for storage.",51,{"inputs":[],"output":{"name":"transactionstorage"}}],[11,"new","","Builds a new object for storage.",31,{"inputs":[],"output":{"name":"triggerstorage"}}]],"paths":[[4,"ProtoItem"],[4,"SetupError"],[3,"SetupConfig"],[3,"Machine"],[4,"TimingItem"],[4,"TriggerItem"],[3,"Start"],[3,"Input"],[3,"EndTurn"],[3,"PlayCard"],[3,"Attack"],[3,"Damage"],[4,"TransactionItem"],[3,"Epsilon"],[4,"EntityTags"],[8,"StateContainer"],[8,"State"],[8,"TriggerState"],[8,"Identifiable"],[8,"EntityBuilder"],[8,"CardTrait"],[8,"CardBuilder"],[8,"ServiceCompliance"],[8,"StackStorageCompliance"],[8,"IndexedStorageCompliance"],[8,"ArrayStorageCompliance"],[8,"PullupFrom"],[8,"PushdownFrom"],[8,"TransitionFrom"],[3,"CardStorage"],[3,"UnsafeTrigger"],[3,"TriggerStorage"],[4,"ErrorKind"],[8,"HydratedErrorExt"],[8,"FrontendErrorExt"],[3,"OverflowError"],[3,"MissingEntityError"],[3,"MissingCardError"],[3,"MissingPropertyError"],[3,"MissingPrototypeError"],[3,"IDCollisionError"],[4,"TriggerFail"],[8,"PullupInto"],[8,"PushdownInto"],[8,"TransitionInto"],[3,"RuntimeConstraintError"],[3,"MachineError"],[3,"TransactionUnpackError"],[3,"InvalidEntityMutUnwrap"],[3,"StackPopError"],[3,"StackPushError"],[3,"TransactionStorage"],[3,"CardService"],[3,"Action"],[3,"Wait"],[3,"Peri"],[3,"EntityService"],[3,"TriggerWrapper"],[3,"CardId"],[3,"DeathEffect"],[3,"Post"],[3,"Trigger"],[3,"RecurseEffect"],[3,"Pre"],[3,"EntityStorage"],[3,"Finished"],[3,"Effect"],[3,"TriggerService"]]};
searchIndex["main"] = {"doc":"","items":[],"paths":[]};
searchIndex["medici_core"] = {"doc":"Types for implementing a state machine for (board) games. This crate provides an opinionated framework which the developers can use for their own games.","items":[[0,"prefab","medici_core","Types with ubiquitous usage within state machines (containers) or specific to the opiniated nature of this framework. Framework users are encouraged to use these types whenever possible. The services are built to make use of these types, but freedom was preserved wherever possible.",null,null],[0,"card","medici_core::prefab","Module containing items to work with game cards.",null,null],[3,"CardStruct","medici_core::prefab::card","Type representing a game card.",null,null],[12,"name","","Holds the name of this card.",0,null],[12,"state","","Holds the properties attributed to this card.",0,null],[12,"triggers","","Holds all triggers registered on this card.",0,null],[6,"Card","","Card structure which makes use of the items defined by the medici_core::prefab module.",null,null],[17,"GAME_CARD_ID","","Reserved identifier for Game cards.",null,null],[17,"PLAYER_CARD_ID","","Reserved identifier for Player cards.",null,null],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"cardstruct"}}],[11,"id","","",0,{"inputs":[{"name":"self"}],"output":{"name":"cardid"}}],[11,"new_with_id","","",0,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"get_value_default","","Retrieves the value of the requested property defined within this card. 0 is returned as default value when the property key was not found!",0,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"u32"}}],[11,"get_value","","Retrieves the value of the requested property defined within this card.",0,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"generics":["u32","missingpropertyerror"],"name":"result"}}],[11,"set_value","","Store the provided property key with corresponding value into this card.",0,{"inputs":[{"name":"self"},{"name":"s"},{"name":"u32"}],"output":{"generics":["u32"],"name":"option"}}],[11,"get","","",0,{"inputs":[{"name":"self"}],"output":{"name":"triggerservice"}}],[11,"get_mut","","",0,{"inputs":[{"name":"self"}],"output":{"name":"triggerservice"}}],[0,"entity","medici_core::prefab","Module containing standard entity structures.",null,null],[3,"EntityStruct","medici_core::prefab::entity","Type representing a stateful 'thing' within the state-machine.",null,null],[12,"state","","Contains all properties attributed to this entity.",1,null],[12,"prototypes","","Contains a set of behaviours that are attributed to this entity.",1,null],[12,"human_readable","","Provides the option to assign a string to this entity.",1,null],[6,"Entity","","Entity structure which makes use of structures defined by the medici_core::prefab module.",null,null],[17,"GAME_E_ID","","The game entity should always have ID 0.",null,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"entitystruct"}}],[11,"id","","",1,null],[11,"new_with_id","","",1,{"inputs":[{"name":"entityid"}],"output":{"name":"self"}}],[11,"get_value_default","","Retrieves the value of the requested property defined within this entity. 0 is returned as default value when the property key was not found!",1,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"u32"}}],[11,"get_value","","Retrieves the value of the requested property defined within this entity.",1,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"generics":["u32","missingpropertyerror"],"name":"result"}}],[11,"set_value","","Store the provided property key with corresponding value into this entity.",1,{"inputs":[{"name":"self"},{"name":"s"},{"name":"u32"}],"output":{"generics":["u32"],"name":"option"}}],[11,"add_proto","","Attach new behaviour to this specific entity.",1,{"inputs":[{"name":"self"}],"output":null}],[11,"remove_proto","","Removes behaviour from this specific entity.",1,{"inputs":[{"name":"self"}],"output":null}],[11,"as_proto","","Return this entity as the requested prototype.",1,{"inputs":[{"name":"self"}],"output":{"generics":["missingprototypeerror"],"name":"result"}}],[11,"as_proto_mut","","Return this entity as the requested prototype.",1,{"inputs":[{"name":"self"}],"output":{"generics":["missingprototypeerror"],"name":"result"}}],[0,"prototype","medici_core::prefab","Module containing standard prototypes.",null,null],[3,"GameProto","medici_core::prefab::prototype","Prototype for game related behaviour.",null,null],[12,"0","","",2,null],[3,"PlayerProto","","Prototype for player related behaviour.",null,null],[12,"0","","",3,null],[4,"Either","","Enum which abtracts immutable and mutable access to entity objects.",null,null],[13,"Imut","","Stores immutable references to entities.",4,null],[13,"Mut","","Store mutable references to entities.",4,null],[4,"ProtoItem","","Autogenerated enum.",null,null],[13,"GameProto","","Autogenerated. See [`GameProto`].",5,null],[13,"PlayerProto","","Autogenerated. See [`PlayerProto`].",5,null],[6,"Game","","Prototype for game behaviour specifically targetting the [`Entity`] defined within medici_core::prefab.",null,null],[6,"Player","","Prototype for player behaviour specifically targetting the [`Entity`] defined within medici_core::prefab.",null,null],[11,"from","","",2,{"inputs":[{"name":"entityprefab"}],"output":{"name":"self"}}],[11,"from","","",2,{"inputs":[{"name":"entityprefab"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"entityprefab"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"entityprefab"}],"output":{"name":"self"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"unwrap","","Returns an immutable reference to the contained [`Entity`].",4,{"inputs":[{"name":"self"}],"output":{"name":"e"}}],[11,"unwrap_mut","","Returns a mutable reference to the contained [`Entity`].",4,{"inputs":[{"name":"self"}],"output":{"generics":["invalidentitymutunwrap"],"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"protoitem"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"protoitem"}],"output":{"name":"bool"}}],[11,"hash","","",5,null],[0,"runtime","medici_core::prefab","Module containing methods which make working with the state machine a bit easier.",null,null],[5,"fetch_triggers","medici_core::prefab::runtime","Extract all triggers from the provided machine for matching conditions.",null,{"inputs":[{"name":"m"}],"output":{"generics":["unsafetrigger"],"name":"vec"}}],[5,"exec_trigger_stepped","","Executes all passed down triggers for the provided machine.",null,{"inputs":[{"name":"m"},{"name":"i"}],"output":{"generics":["machineerror"],"name":"result"}}],[0,"state","medici_core::prefab","Module containing often used state types.",null,null],[3,"Wait","medici_core::prefab::state","State indicating a pause until an input event has been generated.",null,null],[3,"Action","","State indicating dynamic execution of the specific action is in progress.",null,null],[3,"Finished","","State indicating finalization of the state machine.",null,null],[3,"Effect","","First state used to execute an effect chain caused by the substate ([`Actionable`]).",null,null],[3,"RecurseEffect","","Chained effect caused by an specific [`Actionable`].",null,null],[3,"DeathEffect","","Specific state where [`Entity`] death processing is triggered.",null,null],[3,"Trigger","","Exact state used to execute effects.",null,null],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"wait"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"action"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"finished"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"effect"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"recurseeffect"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"deatheffect"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"trigger"}}],[0,"timing","medici_core::prefab","Module containing ready-to-use types which can be used to construct trigger constraints.",null,null],[3,"Pre","medici_core::prefab::timing","Type representing a timing relationship. Pre X means before X is executed.",null,null],[3,"Peri","","Type representing a timing relationship. Peri X means during/while X is executed.",null,null],[3,"Post","","Type representing a timing relationship. Pre X means after X is executed.",null,null],[4,"TimingItem","","Autogenerated enum.",null,null],[13,"Pre","","Autogenerated. See [`Pre`].",13,null],[13,"Peri","","Autogenerated. See [`Peri`].",13,null],[13,"Post","","Autogenerated. See [`Post`].",13,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"pre"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"peri"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"post"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"timingitem"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"timingitem"}],"output":{"name":"bool"}}],[11,"hash","","",13,null],[0,"transaction","medici_core::prefab","Types for provisioning the next state when performing a transition within the state machine.",null,null],[3,"Epsilon","medici_core::prefab::transaction","Empty Transaction object.",null,null],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"epsilon"}}],[0,"trigger","medici_core::prefab","Module containing ready-to-use types which can be used to construct trigger constraints.",null,null],[3,"GameStart","medici_core::prefab::trigger","Type representing the event when a game starts.",null,null],[3,"GameEnd","","Type representing the event when a game ends.",null,null],[3,"TurnStart","","Type representing the event when a player's turn starts.",null,null],[3,"TurnEnd","","Type representing the event when a player's turn ends.",null,null],[4,"TriggerItem","","Autogenerated enum.",null,null],[13,"GameStart","","Autogenerated. See [`GameStart`].",18,null],[13,"GameEnd","","Autogenerated. See [`GameEnd`].",18,null],[13,"TurnStart","","Autogenerated. See [`TurnStart`].",18,null],[13,"TurnEnd","","Autogenerated. See [`TurnEnd`].",18,null],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"gamestart"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"gameend"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"turnstart"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"turnend"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"triggeritem"}}],[11,"eq","","",18,{"inputs":[{"name":"self"},{"name":"triggeritem"}],"output":{"name":"bool"}}],[11,"hash","","",18,null],[0,"ctstack","medici_core","Module which implements a CONS-LIST for transition validation at compile time.",null,null],[6,"ZeroSizedType","medici_core::ctstack","Re-exported because standard library module (std) is private. Consequentially macros cannot directly use std types which are not inside the std-prelude.",null,null],[6,"EmptyStack","","Type for starting a new CTStack.",null,null],[6,"AnyStack","","Type representing aq CTStack with any contents.",null,null],[8,"CTStack","","Traits facilitating implementation of a compile-time stack.",null,null],[16,"Head","","Type of the front of the stack.",23,null],[16,"Tail","","Type of the next to front type on the stack.",23,null],[0,"macros","medici_core","Defines useful macro's to simplify syntax of implementations",null,null],[0,"error","","Types, to be used within the system, providing context of unexpected behaviour.",null,null],[3,"MachineError","medici_core::error","User facing error type indicating a failure during evalutation/computation of the state machine.",null,null],[4,"ErrorKind","","Enumeration of publicl cases of state machine failures.",null,null],[13,"ConstraintError","","Error indicating some constraint failed to assert at runtime.",24,null],[13,"LogicError","","Error indicating the developer has introduced a logic error in his code.",24,null],[13,"Custom","","Error allowing to print an entirely custom message",24,null],[0,"custom_type","","Error types which represent one specific kind of error (failure). These errors are reported within functions that manipulate properties of the state machine, but will be wrapped into [`MachineError`] eventually.",null,null],[3,"RuntimeConstraintError","medici_core::error::custom_type","Type used for indicating failure to meet specified constraints.",null,null],[3,"TransactionUnpackError","","Code failed to push a new item onto the chosen stack.",null,null],[3,"StackPushError","","Code failed to push a new item onto the chosen stack.",null,null],[3,"StackPopError","","Code failed to push a new item onto the chosen stack.",null,null],[3,"OverflowError","","Specific error thrown to indicate the system cannot execute the request under constrained circumstances.",null,null],[12,"0","","",25,null],[3,"InvalidEntityMutUnwrap","","Code failed to get a mutable reference to an [`Entity`].",null,null],[3,"MissingEntityError","","Specific error thrown when the requested entity-id is not known.",null,null],[12,"0","","",26,null],[3,"MissingCardError","","Specific error thrown when the requested card-id is not known.",null,null],[12,"0","","",27,null],[3,"MissingPropertyError","","Specific error thrown when the requested property is not known.",null,null],[12,"0","","",28,null],[12,"1","","",28,null],[3,"MissingPrototypeError","","Specific error thrown when the requested entity-id is not known.",null,null],[12,"0","","",29,null],[12,"1","","",29,null],[3,"IDCollisionError","","Error thrown when the provided object's ID collides with an already known ID.",null,null],[12,"0","","",30,null],[4,"TriggerFail","","Enumeration of failure cases working with [`Trigger`]s.",null,null],[13,"CallbackNull","","Error indicating the callback pointer is invalid.",31,null],[13,"ConstraintFail","","Error indicating the provided machine does not validate the [`Trigger`] constraints.",31,null],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",32,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",32,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",32,null],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",33,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",33,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",34,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",34,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",35,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",35,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",25,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",25,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",36,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",36,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",31,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",31,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"triggerfail"}}],[11,"eq","","",31,{"inputs":[{"name":"self"},{"name":"triggerfail"}],"output":{"name":"bool"}}],[8,"HydratedErrorExt","medici_core::error","TODO",null,null],[10,"hydrate","","TODO",37,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"machineerror"}}],[8,"FrontendErrorExt","","Trait facilitating error creation with a snapshot of the state machine attached.",null,null],[10,"infuse","","Builds a [`MachineError`] from some error or empty option.",38,{"inputs":[{"name":"self"},{"name":"errorkind"},{"name":"i"}],"output":{"name":"machineerror"}}],[10,"infuse_with","","Builds a [`MachineError`] from some error or empty option. The [`ErrorKind`] invariant will be [`ErrorKind::Custom`] which will contain the string type passed into this method.",38,{"inputs":[{"name":"self"},{"name":"f"},{"name":"m"}],"output":{"name":"machineerror"}}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",39,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",39,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"cause","","",24,{"inputs":[{"name":"self"}],"output":{"generics":["fail"],"name":"option"}}],[11,"backtrace","","",24,{"inputs":[{"name":"self"}],"output":{"generics":["backtrace"],"name":"option"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"errorkind"}}],[11,"eq","","",24,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"bool"}}],[11,"ne","","",24,{"inputs":[{"name":"self"},{"name":"errorkind"}],"output":{"name":"bool"}}],[0,"function","medici_core","Contains the core functionality items for our system.",null,null],[3,"CardId","medici_core::function","Type that's generally used to identify and order [`Card`] objects.",null,null],[6,"EntityId","","Type that's generally used to identify and order [`Entity`] objects.",null,null],[8,"StateContainer","","Trait generalizing over any structure that could act as a container of states.",null,null],[16,"State","","Type of the current state held by the state machine.",40,null],[16,"Transaction","","Type of transaction object necessary to transition into the current state of the machine.",40,null],[16,"TimingEnum","","Type which enumerates all possible timings contained by the machine.",40,null],[16,"TriggerEnum","","Type which enumerates all possible triggers contained by the machine.",40,null],[16,"TransitionRecord","","Type representing the stack of types where the container state was transitioned in a pushdown manner.",40,null],[8,"State","","Trait generalizing over any state that's present in the state machine.",null,null],[16,"Transaction","","Type of structure which must be provided when transitioning into the state represented by the enclosing type.",41,null],[8,"EffectState","","Trait generalizing over any state which is used to bootstrap an execution of triggers.",null,null],[8,"TriggerState","","Trait generalizing over any state that's used to pass into trigger callbacks when trigger conditions are met.",null,null],[16,"Timing","","Encoded type value representing the timing (related to triggers) of the current state.",42,null],[16,"Trigger","","Encoded type value representing the trigger of the current state.",42,null],[8,"Identifiable","","Trait enforcing implementing objects to expose their identifier. The uniqueness of this identifier depends on the implementing object itself.",null,null],[16,"ID","","The type of identifier used to pass between functions during state machine execution. This type MUST be [`Copy`] because storing this identifier is the idiomatic way of passing \"references\" around.",43,null],[10,"id","","Returns the identifier of the implementing object.",43,null],[8,"Entity","","Trait representing an object which properties can be altered dynamically (at runtime).",null,null],[8,"EntityBuilder","","Trait used to create a new [`Entity`] object.",null,null],[10,"new_with_id","","Build a new [`Entity`] with the provided identifier.",44,null],[8,"Card","","Trait representing an actual game card.",null,null],[16,"TimingEnum","","All timing types this card holds listeners for.",45,null],[16,"TriggerEnum","","All trigger types this card holds listeners for.",45,null],[8,"CardBuilder","","Trait used to create a new [`Card`] object.",null,null],[10,"new_with_id","","Build a new [`Card`] with the provided identifier.",46,{"inputs":[{"name":"i"}],"output":{"name":"c"}}],[8,"ServiceCompliance","","Trait for implementing a certain service on the state machine.",null,null],[10,"get","","Retrieves an immutable reference to service `S`.",47,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[10,"get_mut","","Retrieves a mutable reference to service `S`.",47,{"inputs":[{"name":"self"}],"output":{"name":"s"}}],[8,"StackStorageCompliance","","Defines stack behaviour for a certain storage object.",null,null],[16,"Item","","The type of items found within the implementing storage.",48,null],[10,"push","","Adds the provided item onto this stack.",48,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[10,"pop","","Removes the top most item of the stack.",48,{"inputs":[{"name":"self"}],"output":{"generics":["stackpoperror"],"name":"result"}}],[8,"IndexedStorageCompliance","","Defines indexed behaviour for a certain storage object.",null,null],[16,"Item","","The type of items found within the implementing storage.",49,null],[10,"get","","Retrieves a reference to the requested item matching the provided identifier.",49,null],[10,"get_mut","","Retrieves a reference to the requested item matching the provided identifier.",49,null],[8,"ArrayStorageCompliance","","Defines array access behaviour for storage objects.",null,null],[16,"Item","","The type of items found within the implementing storage.",50,null],[10,"as_slice","","Returns the current storage as a slice, which is an indexed storage.",50,null],[10,"as_slice_mut","","Returns the current storage as a slice, which is an indexed storage.",50,null],[11,"fmt","","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",51,{"inputs":[{"name":"self"}],"output":{"name":"cardid"}}],[11,"fmt","","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new identifier structure for a card.",51,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"self"}}],[11,"from_set","","Creates a new identifier structure for a card.",51,{"inputs":[{"name":"s"},{"name":"u32"}],"output":{"name":"self"}}],[0,"marker","medici_core","Primitive traits which can be used as constraints by the core components.",null,null],[8,"Transaction","medici_core::marker","Types used to transition between state machine States.",null,null],[8,"TransactionContainer","","Types which generalize multiple transactions into 1 [`Sized`] structure so the transactions themselves can be safely stored in memory.",null,null],[8,"Service","","Types which attribute functionality to state machines.",null,null],[8,"ProtoEnumerator","","Types which enumerate all known [`Prototype`]s.",null,null],[8,"Prototype","","Types which attribute functionality to [`Entity`]s within the machine.",null,null],[8,"TimingEnumerator","","Types which enumerate all possible timings at which moment a trigger can be executed.",null,null],[8,"Timing","","Types which reflect the timing when a [`Triggerable`] should be executed.",null,null],[8,"TriggerEnumerator","","Types which enumerate all possible triggers which the machine facilitates reacting to.",null,null],[8,"Triggerable","","(State) Types which reflect an event after which functionality awaiting these events will be executed.",null,null],[8,"TopLevel","","(State) Types which are directly contained by the state machine.",null,null],[8,"Waitable","","(State) Types which represent a condition for when the state machine itself should resume execution.",null,null],[8,"Actionable","","(State) Types which represent actions a user want to perform that activate the machine to work out its effects.",null,null],[0,"service","medici_core","Types that provide functionality to your application. These types can be added AD-HOC to your (state) machine declaration. Other components of this framework also need some of these services to be implemented before use.",null,null],[0,"card","medici_core::service","Contains functionality to work with [`Card`]s.",null,null],[3,"CardService","medici_core::service::card","Object allowing manipulation of game [`Card`]s.",null,null],[11,"fmt","","",52,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new object of this service.",52,{"inputs":[],"output":{"name":"self"}}],[11,"register_card","","Stores the provided card.",52,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"generics":["idcollisionerror"],"name":"result"}}],[11,"get_card","","Fetches the card matching the provided identifier from this storage object.",52,null],[0,"entity","medici_core::service","Contains functionality to work with [`Entity`]s.",null,null],[3,"EntityService","medici_core::service::entity","Structure for working with [`Entity`] objects.",null,null],[11,"fmt","","",53,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",53,{"inputs":[{"name":"self"}],"output":{"name":"entityservice"}}],[11,"new","","Creates a new object for storage.",53,{"inputs":[{"name":"m"}],"output":{"name":"self"}}],[11,"new_entity","","Build a new entity which is kept inside this storage object.",53,{"inputs":[{"name":"self"}],"output":{"generics":["overflowerror"],"name":"result"}}],[11,"get","","Retrieves a reference to the entity matching the id.",53,null],[11,"get_mut","","Retrieves a mutable reference to the entity matching the id.",53,null],[0,"trigger","medici_core::service","Contains the functionality to work with [`Trigger`]s.",null,null],[3,"TriggerWrapper","medici_core::service::trigger","Safe abstraction over UnsafeTrigger objects.",null,null],[3,"TriggerService","","Structure wrapping and containing all [`Trigger`]s registered on the state machine.",null,null],[11,"fmt","","",54,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Constructs a new trigger method wrapper from the provided method.",54,null],[11,"try_from_trigger_entry","","Build a safe wrapper from a [`UnsafeTrigger`] object.",54,{"inputs":[{"name":"unsafetrigger"}],"output":{"generics":["triggerfail"],"name":"result"}}],[11,"into_callback","","Consumes this wrapper to retrieve the callback it contains.",54,null],[11,"fmt","","",55,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",55,{"inputs":[{"name":"self"}],"output":{"name":"triggerservice"}}],[11,"new","","Creates a new object of this service.",55,{"inputs":[],"output":{"name":"self"}}],[11,"add_trigger","","Add a new trigger to the store.",55,null],[11,"retrieve_all_triggers","","Returns an iterator over all stored triggers.",55,null],[11,"retrieve_triggers","","Retrieve all triggers matching the provided machine.",55,null],[0,"stm","medici_core","Traits enforcing state machine behaviour.",null,null],[0,"checked","medici_core::stm","(Type) Checked transitions for state machines.",null,null],[8,"PullupInto","medici_core::stm::checked","Syntax simplifying trait in accordance to [`PullupFrom`].",null,null],[10,"pullup","","In accordance with [`PullupFrom::pullup_from`].",56,{"inputs":[{"name":"self"}],"output":{"generics":["machineerror"],"name":"result"}}],[8,"PushdownInto","","Syntax simplifying trait in accordance to [`PushdownFrom`].",null,null],[10,"pushdown","","In accordance with [`PushdownFrom::pushdown_from`].",57,null],[8,"TransitionInto","","Syntax simplifying trait in accordance to [`TransitionFrom`].",null,null],[10,"transition","","In accordance with [`TransitionFrom::transition_from`].",58,null],[8,"TransitionFrom","","Trait defining the contract for one-way transitions of the state machine. This kind of transition preserves the state change history.",null,null],[10,"transition_from","","Transition from the provided state into the implementing state.",59,null],[8,"PushdownFrom","","Trait defining the contract for two-way transitions of the state machine. The transition this trait defines is meant as a temporary one where the control flow will result in the state machine eventually performs a [`PullupFrom`] transition. Effectively reversing the Pushdown. The Transaction object of the outgoing state is stored for re-use. This kind of transition will write state change history into the compile-time stack ([`CTStack`]).",null,null],[10,"pushdown_from","","Transition from the provided state into the implementing state.",60,null],[8,"PullupFrom","","Trait defining the contract for two-way transitions of the state machine. The Transaction object of the outgoing state is stored for re-use. This kind of transition will write state change history into the compile-time stack ([`CTStack`]).",null,null],[10,"pullup_from","","Transition from the provided state into the implementing state.",61,{"inputs":[{"name":"t"}],"output":{"generics":["machineerror"],"name":"result"}}],[0,"storage","medici_core","Types with each different functionality to store data.",null,null],[0,"card","medici_core::storage","Module containing structures for storing game card objects.",null,null],[3,"CardStorage","medici_core::storage::card","Structure holding onto all cards defined for a specific machine.",null,null],[12,"cards","","Contains the cards.",62,null],[11,"fmt","","",62,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",62,{"inputs":[{"name":"self"}],"output":{"name":"cardstorage"}}],[11,"get","","",62,null],[11,"get_mut","","",62,null],[11,"new","","Creates a new object for card storage.",62,{"inputs":[],"output":{"name":"self"}}],[11,"try_insert_card","","Tries to insert the provided card into this storage object.",62,{"inputs":[{"name":"self"},{"name":"c"}],"output":{"generics":["idcollisionerror"],"name":"result"}}],[0,"entity","medici_core::storage","Module containing structures for storing entities.",null,null],[3,"EntityStorage","medici_core::storage::entity","Structure wrapping a [`Vec`] to provide a container for (all) entities within the state machine.",null,null],[11,"fmt","","",63,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",63,{"inputs":[{"name":"self"}],"output":{"name":"entitystorage"}}],[11,"new","","Creates a new object for storage.",63,{"inputs":[],"output":{"name":"self"}}],[11,"push","","Stores the provided item into this object.",63,{"inputs":[{"name":"self"},{"name":"e"}],"output":null}],[11,"as_slice","","",63,null],[11,"as_slice_mut","","",63,null],[0,"transaction","medici_core::storage","Module containing types for storing [`Transaction`] objects.",null,null],[3,"TransactionStorage","medici_core::storage::transaction","Object for storing [`Transaction`] objects.",null,null],[11,"fmt","","",64,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",64,{"inputs":[{"name":"self"}],"output":{"name":"transactionstorage"}}],[11,"new","","Creates a new instance of for storage.",64,{"inputs":[],"output":{"name":"self"}}],[11,"push","","",64,{"inputs":[{"name":"self"},{"name":"i"}],"output":null}],[11,"pop","","",64,{"inputs":[{"name":"self"}],"output":{"generics":["stackpoperror"],"name":"result"}}],[0,"trigger","medici_core::storage","Module containing types for storing game triggers.",null,null],[3,"UnsafeTrigger","medici_core::storage::trigger","Structure serializng/generalizing a trigger.",null,null],[12,"timing","","(Sized) Timing value belonging to the callback, see func_pointer.",65,null],[12,"trigger","","(Sized) Trigger value belonging to the callback, see func_pointer.",65,null],[12,"func_pointer","","The callback pointer which must be transmuted and executed when the conditions of the running state machine match the ones contained within this structure.",65,null],[3,"TriggerStorage","","Structure used to store a portable format of trigger entries, see [`UnsafeTrigger`].",null,null],[12,"triggers","","Container of all triggers registered with the running state machine.",66,null],[11,"fmt","","",65,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",65,{"inputs":[{"name":"self"}],"output":{"name":"unsafetrigger"}}],[11,"fmt","","",66,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",66,{"inputs":[{"name":"self"}],"output":{"name":"triggerstorage"}}],[11,"new","","Builds a new object for storage.",66,{"inputs":[],"output":{"name":"self"}}],[0,"transaction","medici_core","Core functionality helper methods.",null,null],[5,"pack_transaction","medici_core::transaction","Transform a transaction into the wrapping variant.",null,{"inputs":[{"name":"t"}],"output":{"name":"tc"}}],[5,"unpack_transaction","","Unpack a wrapped transaction into an owned value.",null,{"inputs":[{"name":"tc"}],"output":{"generics":["transactionunpackerror"],"name":"result"}}],[14,"build_exec_triggers_checked","medici_core","Macro used for building a function that automatically constructs a method called [`exec_triggers`].",null,null],[14,"ct","","Usability macro for pushing a new type onto the CTStack.",null,null],[14,"ctxt","","",null,null],[14,"hydrate","","",null,null],[11,"from","medici_core::storage::trigger","",65,{"inputs":[{"name":"triggerwrapper"}],"output":{"name":"self"}}]],"paths":[[3,"CardStruct"],[3,"EntityStruct"],[3,"GameProto"],[3,"PlayerProto"],[4,"Either"],[4,"ProtoItem"],[3,"Wait"],[3,"Action"],[3,"Finished"],[3,"Effect"],[3,"RecurseEffect"],[3,"DeathEffect"],[3,"Trigger"],[4,"TimingItem"],[3,"Pre"],[3,"Peri"],[3,"Post"],[3,"Epsilon"],[4,"TriggerItem"],[3,"GameStart"],[3,"GameEnd"],[3,"TurnStart"],[3,"TurnEnd"],[8,"CTStack"],[4,"ErrorKind"],[3,"OverflowError"],[3,"MissingEntityError"],[3,"MissingCardError"],[3,"MissingPropertyError"],[3,"MissingPrototypeError"],[3,"IDCollisionError"],[4,"TriggerFail"],[3,"RuntimeConstraintError"],[3,"TransactionUnpackError"],[3,"StackPushError"],[3,"StackPopError"],[3,"InvalidEntityMutUnwrap"],[8,"HydratedErrorExt"],[8,"FrontendErrorExt"],[3,"MachineError"],[8,"StateContainer"],[8,"State"],[8,"TriggerState"],[8,"Identifiable"],[8,"EntityBuilder"],[8,"Card"],[8,"CardBuilder"],[8,"ServiceCompliance"],[8,"StackStorageCompliance"],[8,"IndexedStorageCompliance"],[8,"ArrayStorageCompliance"],[3,"CardId"],[3,"CardService"],[3,"EntityService"],[3,"TriggerWrapper"],[3,"TriggerService"],[8,"PullupInto"],[8,"PushdownInto"],[8,"TransitionInto"],[8,"TransitionFrom"],[8,"PushdownFrom"],[8,"PullupFrom"],[3,"CardStorage"],[3,"EntityStorage"],[3,"TransactionStorage"],[3,"UnsafeTrigger"],[3,"TriggerStorage"]]};
searchIndex["medici_derive"] = {"doc":"","items":[],"paths":[]};
initSearch(searchIndex);
